// Â© faiyaz7283

//@version=5

// @description A library of many helper methods, plus a comprehensive print method and a printer object.
library("printer", overlay=true)

// Imports
import faiyaz7283/tools/7 as tools

// Style Objects : {

// Define the `_gradient` UDT.
export type dynamicColor
    float numberUp = 100
    float numberDown = -100
    float numberNeutral = 0
    string stringUp = 'up'
    string stringDown = 'down'
    string stringNeutral = 'flat'
    color up = #00FF00
    color neutral = #fff9c4
    color down = #FF0000
    color offsetColor = na
    string offsetItem = 'text'

__gradient(dynamicColor this, float num) =>
    bottom_value = num > 0 ? this.numberNeutral : this.numberDown
    top_value = num > 0 ? this.numberUp : this.numberNeutral
    bottom_color = num > 0 ? this.neutral : this.down
    top_color = num > 0 ? this.up : this.neutral
    num == 0 ? this.neutral : color.from_gradient(num, bottom_value, top_value, bottom_color, top_color)

// Define the `tableStyle` UDT.
export type tableStyle
    color bgColor = #000000B3
    color frameColor = #3C465047
    int frameWidth = 1
    color borderColor = na
    int borderWidth = 2

// Define the `headerStyle` UDT.
export type headerStyle
    float width = 0
    float height = 0
    string textHalign = text.align_center
    string textValign = text.align_center
    color textColor = #FFFFFF
    string textSize = size.auto
    color bgColor = #3C465087
    string textFontFamily = font.family_default
    string format = na

// Define the `footerStyle` UDT.
export type footerStyle
    float width = 0
    float height = 0
    string textHalign = text.align_center
    string textValign = text.align_center
    color textColor = #FFFFFF
    string textSize = size.auto
    color bgColor = #3C465087
    string textFontFamily = font.family_default
    string format = na

// Define the `titleStyle` UDT.
export type titleStyle
    bool top = true
    float width = 0
    float height = 0
    string textHalign = text.align_center
    string textValign = text.align_center
    color textColor = #FFFFFF
    string textSize = size.auto
    color bgColor = #1E28328C
    string textFontFamily = font.family_default
    string format = na

// Define the `cellStyle` UDT.
export type cellStyle
    bool horizontal = false
    bool timestamp = false
    string timezone = syminfo.timezone
    float width = 0
    float height = 0
    string textHalign = text.align_center
    string textValign = text.align_center
    color textColor = #E14600
    string textSize = size.auto
    color bgColor = na
    string textFontFamily = font.family_default
    string format = na
    dynamicColor dynamicColor = na
    bool gradient = false

// Define the `gutterStyle` UDT.
export type gutterStyle
    bool gutter = true
    float width = 0.01
    float height = 0.01

// }

// Dynamic Value (Objects and methods) : {

export type dv
    string _type
    string stringValue = na
    float floatValue = na
    int intValue = na
    bool boolValue = na
    color colorValue = na

// @function    Create a new 'dv' (dynamic value) object.
// @param this  Use this Object as the dynamic value.
// @returns     (dv) A new 'dv' object.
export method dv(string this) =>
    dv.new(_type='string', stringValue=this)

// METHOD OVERLOAD
export method dv(float this) =>
    dv.new(_type='float', floatValue=this)

// METHOD OVERLOAD
export method dv(int this) =>
    dv.new(_type='int', intValue=this)

// METHOD OVERLOAD
export method dv(bool this) =>
    dv.new(_type='bool', boolValue=this)

// METHOD OVERLOAD
export method dv(color this) =>
    dv.new(_type='color', colorValue=this)

export type dvs
    array<dv> dvsArr = na
    matrix<dv> dvsMx = na

// @function    Create a new 'dvs' (dynamic values) object.
// @param this  Set this object as the dynamic values.
// @returns     (dv) A new 'dvs' object.
export method dvs(array<string> this) =>
    _dvs = array.new<dv>() 
    for val in this
        _dvs.push(dv(val))
    dvs.new(dvsArr=_dvs)

// METHOD OVERLOAD
export method dvs(array<float> this) =>
    _dvs = array.new<dv>() 
    for val in this
        _dvs.push(dv(val))
    dvs.new(dvsArr=_dvs)

// METHOD OVERLOAD
export method dvs(array<int> this) =>
    _dvs = array.new<dv>() 
    for val in this
        _dvs.push(dv(val))
    dvs.new(dvsArr=_dvs)

// METHOD OVERLOAD
export method dvs(array<bool> this) =>
    _dvs = array.new<dv>() 
    for val in this
        _dvs.push(dv(val))
    dvs.new(dvsArr=_dvs)

// METHOD OVERLOAD
export method dvs(array<color> this) =>
    _dvs = array.new<dv>() 
    for val in this
        _dvs.push(dv(val))
    dvs.new(dvsArr=_dvs)

// METHOD OVERLOAD
export method dvs(matrix<string> this) =>
    rows = this.rows()
    cols = this.columns()
    _dvs = matrix.new<dv>(rows, cols, na) 
    for r=0 to rows - 1
        for c=0 to cols - 1
            _dvs.set(r, c, dv(this.get(r, c)))
    dvs.new(dvsMx=_dvs)

// METHOD OVERLOAD
export method dvs(matrix<float> this) =>
    rows = this.rows()
    cols = this.columns()
    _dvs = matrix.new<dv>(rows, cols, na) 
    for r=0 to rows - 1
        for c=0 to cols - 1
            _dvs.set(r, c, dv(this.get(r, c)))
    dvs.new(dvsMx=_dvs)

// METHOD OVERLOAD
export method dvs(matrix<int> this) =>
    rows = this.rows()
    cols = this.columns()
    _dvs = matrix.new<dv>(rows, cols, na) 
    for r=0 to rows - 1
        for c=0 to cols - 1
            _dvs.set(r, c, dv(this.get(r, c)))
    dvs.new(dvsMx=_dvs)

// METHOD OVERLOAD
export method dvs(matrix<bool> this) =>
    rows = this.rows()
    cols = this.columns()
    _dvs = matrix.new<dv>(rows, cols, na) 
    for r=0 to rows - 1
        for c=0 to cols - 1
            _dvs.set(r, c, dv(this.get(r, c)))
    dvs.new(dvsMx=_dvs)

// METHOD OVERLOAD
export method dvs(matrix<color> this) =>
    rows = this.rows()
    cols = this.columns()
    _dvs = matrix.new<dv>(rows, cols, na) 
    for r=0 to rows - 1
        for c=0 to cols - 1
            _dvs.set(r, c, dv(this.get(r, c)))
    dvs.new(dvsMx=_dvs)

// }

// Printer Object : {

// Define the `_printer` UDT.
export type _printer
    string header = na
    string footer = na
    bool stack = true
    string loc = position.middle_center
    bool debug = false
    tableStyle tableStyle = na
    headerStyle headerStyle = na
    footerStyle footerStyle = na
    titleStyle titleStyle = na
    cellStyle keyCellStyle = na
    cellStyle cellStyle = na
    gutterStyle gutterStyle = na
    table _table = na
    int _cTotal = 100
    int _rTotal = 100
    string _slot = na
    int _maxCol = 0
    bool _init = false

// }

// Get background colors : {

__getBgColor(string val, cellStyle cellStyle) =>
    // First assign the default cellStyle bgColor
    bgColor = cellStyle.bgColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'bg'
            bgColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.bgColor
        else
            if val == dc.stringUp
                bgColor := dc.up
            else if val == dc.stringDown
                bgColor := dc.down
            else if val == dc.stringNeutral
                bgColor := dc.neutral
    // Return the bgColor
    bgColor

__getBgColor(bool val, cellStyle cellStyle) =>
    // First assign the default cellStyle bgColor
    bgColor = cellStyle.bgColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        bgColor := dc.offsetItem == 'bg' ? (not na(dc.offsetColor) ? dc.offsetColor : cellStyle.bgColor) : (val == true ? dc.up : dc.down)
    // Return the bgColor
    bgColor

__getBgColor(color val, cellStyle cellStyle) =>
    // First assign the default cellStyle bgColor
    bgColor = cellStyle.bgColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'bg'
            bgColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.bgColor
        else
            bgColor := val
    // Return the bgColor
    bgColor

__getBgColor(float val, cellStyle cellStyle) =>
    // First assign the default cellStyle bgColor
    bgColor = cellStyle.bgColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'bg'
            bgColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.bgColor
        else
            if cellStyle.gradient
                bgColor := __gradient(dc, tools._float(val))
            else
                if val > dc.numberNeutral
                    bgColor := dc.up
                else if val < dc.numberNeutral
                    bgColor := dc.down
                else if val == dc.numberNeutral
                    bgColor := dc.neutral
    // Return the bgColor
    bgColor

__getBgColor(int val, cellStyle cellStyle) =>
    // First assign the default cellStyle bgColor
    bgColor = cellStyle.bgColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'bg'
            bgColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.bgColor
        else
            if cellStyle.gradient
                bgColor := __gradient(dc, tools._float(val))
            else
                if val > dc.numberNeutral
                    bgColor := dc.up
                else if val < dc.numberNeutral
                    bgColor := dc.down
                else if val == dc.numberNeutral
                    bgColor := dc.neutral
    // Return the bgColor
    bgColor

// }

// Get text colors : {

__getTextColor(string val, cellStyle cellStyle) =>
    // First assign the default cellStyle textColor
    textColor = cellStyle.textColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'text'
            textColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.textColor
        else
            if val == dc.stringUp
                textColor := dc.up
            else if val == dc.stringDown
                textColor := dc.down
            else if val == dc.stringNeutral
                textColor := dc.neutral
    // Return the textColor
    textColor

__getTextColor(bool val, cellStyle cellStyle) =>
    // First assign the default cellStyle textColor
    textColor = cellStyle.textColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        textColor := dc.offsetItem == 'text' ? (not na(dc.offsetColor) ? dc.offsetColor : cellStyle.textColor) : (val == true ? dc.up : dc.down)
    // Return the textColor
    textColor

__getTextColor(color val, cellStyle cellStyle) =>
    // First assign the default cellStyle textColor
    textColor = cellStyle.textColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'text'
            textColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.textColor
        else
            textColor := val
    // Return the textColor
    textColor

__getTextColor(float val, cellStyle cellStyle) =>
    // First assign the default cellStyle textColor
    textColor = cellStyle.textColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'text'
            textColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.textColor
        else
            if cellStyle.gradient
                textColor := __gradient(dc, tools._float(val))
            else
                if val > dc.numberNeutral
                    textColor := dc.up
                else if val < dc.numberNeutral
                    textColor := dc.down
                else if val == dc.numberNeutral
                    textColor := dc.neutral
    // Return the textColor
    textColor

__getTextColor(int val, cellStyle cellStyle) =>
    // First assign the default cellStyle textColor
    textColor = cellStyle.textColor
    // Check if there is a dynamicColor object
    dc = cellStyle.dynamicColor
    if not na(dc)
        if dc.offsetItem == 'text'
            textColor := not na(dc.offsetColor) ? dc.offsetColor : cellStyle.textColor
        else
            if cellStyle.gradient
                textColor := __gradient(dc, tools._float(val))
            else
                if val > dc.numberNeutral
                    textColor := dc.up
                else if val < dc.numberNeutral
                    textColor := dc.down
                else if val == dc.numberNeutral
                    textColor := dc.neutral
    // Return the textColor
    textColor


// }

// Get formatted strings : {

__getCellFormatStr(string val, cellStyle cellStyle) =>
    not na(cellStyle.format) ? str.format(cellStyle.format, val) : tools._str(val)

__getCellFormatStr(float val, cellStyle cellStyle) =>
    not na(cellStyle.format) ? str.format(cellStyle.format, val) : tools._str(val)

__getCellFormatStr(int val, cellStyle cellStyle) =>
    _val = tools._str(val)
    if not na(cellStyle.format)
        _val := cellStyle.timestamp ? str.format_time(val, cellStyle.format, cellStyle.timezone) : str.format(cellStyle.format, val)
    _val

__getCellFormatStr(bool val, cellStyle cellStyle) =>
    not na(cellStyle.format) ? str.format(cellStyle.format, val) : tools._str(val)

__getCellFormatStr(color val, cellStyle cellStyle) =>
    not na(cellStyle.format) ? str.format(cellStyle.format, tools._str(val)) : tools._str(val)

// }

// Color themes : {

__theme(string theme) =>
    // Default 'gray'
    tblBgCl    = #0000004D       // _color("black_dark", 70)
    frmCl      = #3C4650B8       // _color("gray_bright", 28)
    cellTxtCl  = #E14600         // _color("orange_dark") 
    otherTxtCl = #E1E1E1         // _color("white_bright")
    titleBgCl  = #1E283273       // _color("gray_medium", 55)
    otherBgCl  = #3C465078       // _color("gray_bright", 53)
    keyBgCl    = #1E28324D	      // _color("gray_medium", 70)
	keyTxtCl   = #E1E1E1	      // _color("white_bright")

    if theme == "blue"
        tblBgCl    := #0000780D  // _color("blue_dark", 95)
        frmCl      := #0000FFB3  // _color("blue_bright", 30)
        cellTxtCl  := #00FFFF    // _color("aqua_bright")
        otherTxtCl := #E1E1E1    // _color("white_bright")
        titleBgCl  := #0078FF9E  // _color("aqua_dark", 38)
        otherBgCl  := #0096FFA6  // _color("aqua_medium", 35)
        keyBgCl    := #0078FF4D  // _color("aqua_dark", 70)
        keyTxtCl   := #E1E1E1	  // _color("white_bright")
    else if theme == "green"
        tblBgCl    := #0078000D  // _color("green_dark", 95)
        frmCl      := #00FF00B8  // _color("green_bright", 28)
        cellTxtCl  := #E1E1E1    // _color("white_bright")
        otherTxtCl := #000000    // _color("black_dark")
        titleBgCl  := #00C800D9  // _color("green_light", 15)
        otherBgCl  := #00FF00DE  // _color("green_bright", 13)
        keyBgCl    := #00C80099  // _color("green_light", 40)
        keyTxtCl   := #000000    // _color("black_dark")
    else if theme == "orange"
        tblBgCl    := #E146000D  // _color("orange_dark", 95)
        frmCl      := #E16400B8  // _color("orange_bright", 28)
        cellTxtCl  := #E1E1E1    // _color("white_bright")
        otherTxtCl := #000000    // _color("black_dark")
        titleBgCl  := #E14600D9  // _color("orange_dark", 15)
        otherBgCl  := #E16400DE  // _color("orange_bright", 13)
        keyBgCl    := #E1460099  // _color("orange_dark", 40)
        keyTxtCl   := #000000	  // _color("black_dark")
    else if theme == "pink"
        tblBgCl    := #FF00FF0D  // _color("pink_dark", 95)
        frmCl      := #FF96FFB8  // _color("pink_bright", 28)
        cellTxtCl  := #E1E1E1    // _color("white_bright")
        otherTxtCl := #000000    // _color("black_dark")
        titleBgCl  := #FF64FFD9  // _color("pink_light", 15)
        otherBgCl  := #FF96FFDE  // _color("pink_bright", 13)
        keyBgCl    := #FF64FF99  // _color("pink_light",40)
        keyTxtCl   := #000000	  // _color("black_dark")
    else if theme == "purple"
        tblBgCl    := #9B00FF0D  // _color("purple_dark", 95)
        frmCl      := #9696FFB8  // _color("purple_bright", 28)
        cellTxtCl  := #E1E1E1    // _color("white_bright")
        otherTxtCl := #E1E1E1    // _color("white_bright")
        titleBgCl  := #9664FFD9  // _color("purple_light", 15)
        otherBgCl  := #9696FFDE  // _color("purple_bright", 13)
        keyBgCl    := #9664FF99  // _color("purple_light", 40)
        keyTxtCl   := #E1E1E1	  // _color("white_bright")
    else if theme == "red"
        tblBgCl    := #7800000D  // _color("red_dark", 95)
        frmCl      := #FF0000B8  // _color("red_bright", 28)
        cellTxtCl  := #E1E1E1    // _color("white_bright")
        otherTxtCl := #E1E1E1    // _color("white_bright")
        titleBgCl  := #C80000D9  // _color("red_light", 15)
        otherBgCl  := #FF0000DE  // _color("red_bright", 13)
        keyBgCl    := #C8000099  // _color("red_light", 40)
        keyTxtCl   := #E1E1E1	  // _color("white_bright")
    else if theme == "white"
        tblBgCl    := #C8C8C80D  // _color("white_dark", 95)
        frmCl      := #FFFFFFB8  // _color("white_bright", 28)
        cellTxtCl  := #E1E1E1    // _color("white_bright")
        otherTxtCl := #000000    // _color("black_dark")
        titleBgCl  := #C8C8C8D9  // _color("white_dark", 15)
        otherBgCl  := #EBEBEBDE  // _color("white_light", 13)
        keyBgCl    := #C8C8C899  // _color("white_dark", 40)
        keyTxtCl   := #000000	  // _color("black_dark")
    else if theme == "yellow"
        tblBgCl    := #AFAF000D  // _color("yellow_dark", 95)
        frmCl      := #FFFF00B8  // _color("yellow_bright", 28)
        cellTxtCl  := #E1E1E1    // _color("white_bright")
        otherTxtCl := #000000    // _color("black_dark")
        titleBgCl  := #E6E600D9  // _color("yellow_light", 15)
        otherBgCl  := #FFFF00DE  // _color("yellow_bright", 13)
        keyBgCl    := #E6E60099  // _color("yellow_light", 40)
        keyTxtCl   := #000000	  // _color("black_dark")
    [tblBgCl, frmCl, cellTxtCl, otherTxtCl, titleBgCl, otherBgCl, keyBgCl, keyTxtCl]

// @function         Set a color theme for the printer object using pre-defined theme names.
// @param this       (_printer) A _printer UDT object. 
// @param theme      (string) The name of the theme. Choices: gray, blue, green, orange, red, purple, pink and white. Gray is always default.
// @returns          (_printer) Returns the _printer UDT object.
export method theme(_printer this, string theme) =>
    [tblBgCl, frmCl, cellTxtCl, otherTxtCl, titleBgCl, otherBgCl, keyBgCl, keyTxtCl] = __theme(theme)
    // Styling for table.
    if na(this.tableStyle)
        this.tableStyle := tableStyle.new(bgColor=tblBgCl, frameColor=frmCl)
    else
        this.tableStyle.bgColor := tblBgCl
        this.tableStyle.frameColor := frmCl
    // Styling for Header.
    if na(this.headerStyle)
        this.headerStyle := headerStyle.new(textColor=otherTxtCl, bgColor=otherBgCl)
    else
        this.headerStyle.textColor := otherTxtCl
        this.headerStyle.bgColor := otherBgCl
    // Styling for Footer.
    if na(this.footerStyle)
        this.footerStyle := footerStyle.new(textColor=otherTxtCl, bgColor=otherBgCl)
    else
        this.footerStyle.textColor := otherTxtCl
        this.footerStyle.bgColor := otherBgCl
    // Styling for Title.
    if na(this.titleStyle)
        this.titleStyle := titleStyle.new(textColor=otherTxtCl, bgColor=titleBgCl)
    else
        this.titleStyle.textColor := otherTxtCl
        this.titleStyle.bgColor := titleBgCl
    // Styling for any `Key` cell(s).
    if na(this.keyCellStyle)
        this.keyCellStyle := cellStyle.new(textColor=keyTxtCl, bgColor=keyBgCl)
    else
        this.keyCellStyle.textColor := keyTxtCl
        this.keyCellStyle.bgColor := keyBgCl
    // Styling for Cell.
    if na(this.cellStyle)
        this.cellStyle := cellStyle.new(textColor=cellTxtCl)
    else
        this.cellStyle.textColor := cellTxtCl
    this

// Set custom theme colors for a single print method.
___printThemeSetup(printer, theme, titleStyle titleStyle=na, cellStyle cellStyle=na, cellStyle keyCellStyle=na, cellStyle keyCellStyle2=na) =>
    ts = not na(titleStyle) ? titleStyle : (not na(printer.titleStyle) ? titleStyle.copy(printer.titleStyle) : titleStyle.new())
    cs = not na(cellStyle) ? cellStyle : (not na(printer.cellStyle) ? cellStyle.copy(printer.cellStyle) : cellStyle.new())
    _kcs = not na(printer.keyCellStyle) ? cellStyle.copy(printer.keyCellStyle) : cellStyle.new(textColor=#E1E1E1, bgColor=#1E28324D)
    kcs = not na(keyCellStyle) ? keyCellStyle : _kcs
    kcs2 = not na(keyCellStyle2) ? keyCellStyle2 : _kcs
    
    if not na(theme)
        [tblBgCl, frmCl, cellTxtCl, otherTxtCl, titleBgCl, otherBgCl, keyBgCl, keyTxtCl] = __theme(theme)
        ts.textColor := otherTxtCl
        ts.bgColor := titleBgCl
        cs.textColor := cellTxtCl
        kcs.textColor := keyTxtCl
        kcs.bgColor := keyBgCl
        kcs2.textColor := keyTxtCl
        kcs2.bgColor := keyBgCl
    [ts, cs, kcs, kcs2]

// }

// Misc : {

// Tooltip
__toolTip(_printer printer, col, row, cell, string val, int idx=na, int keyIdx=na, string key=na, int pkIdx=na, string pk=na, int dkIdx=na, string dk=na, int mCol=na, int mRow=na, string _type=na) =>
    _tp = not na(_type) ? _type : tools._type(val)
    tooltip = str.format("column: {0}\nrow: {1}\ncell: {2}\ntype: {3}", col, row, cell, _tp)
    if cell == "gutter"
        gs = printer.gutterStyle
        tooltip := str.format("column: {0}\nrow: {1}\ncell: {2}\nwidth: {3}\nheight: {4}", col, row, cell, gs.width, gs.height)
    else if _tp == "string" or _tp == "array<string>" or _tp == "matrix<string>"
        tooltip := str.format("{0}\nlength: {1}", tooltip, str.length(val))
    else if str.startswith(_tp, "array")
        tooltip := str.format("{0}\nindex: {1}", tooltip, idx)
    else if str.startswith(_tp, "matrix")
        tooltip := str.format("{0}\nmatrix col: {1}\nmatrix row: {2}", tooltip, mCol, mRow)
    else if _tp == 'data2d'
        tooltip := cell == 'key' ? str.format("{0}\nkey index: {1}", tooltip, keyIdx) : str.format("{0}\nkey: {1}", tooltip, key)
    else if _tp == 'data3d' and cell == 'primary key'
        tooltip := str.format("{0}\nprimary key index: {1}", tooltip, pkIdx)
    else if _tp == 'data3d' and cell == 'data key'
        tooltip := str.format("{0}\ndata key index: {1}", tooltip, dkIdx)
    else if _tp == 'data3d' and cell == 'cell'
        tooltip := str.format("{0}\nprimary key: {1}\ndata key: {2}", tooltip, pk, dk)
    tooltip := cell == "gutter" ? tooltip : str.format("{0}\nvalue: {1}", tooltip, tools._str(val))
    printer.debug ? tooltip : val

// Header
__header(_printer printer, bool init=false) =>
    if not na(printer.header)
        if printer._maxCol > 0
            // Readjustment: This keeps header adjusted in a single cell.
            // Note: Gutter (single cell space between each data sets) requires 1 additional column per set.
            //       So on non-stack setup, if gutter is turned on, we have to remove 2 extra spaces from the end to even it out, else 1.
            maxCol = printer.stack ? printer._maxCol : printer._maxCol - (printer.gutterStyle.gutter ?  2 : 1)
            printer._table.clear(0, 0, maxCol, 0)
            printer._table.merge_cells(0, 0, maxCol, 0)
        hs = printer.headerStyle
        format = hs.format
        val = printer.header
        val := not na(format) ? str.format(format, val) : val
        tooltip = __toolTip(printer, 0, 0, "header", printer.header, _type="string")
        printer._table.cell(0, 0, text=val, width=hs.width, height=hs.height, text_color=hs.textColor, text_halign=hs.textHalign, text_valign=hs.textValign, text_size=hs.textSize, bgcolor=hs.bgColor, tooltip=tooltip, text_font_family=hs.textFontFamily)     
    
// Footer
__footer(_printer printer, bool init=false) =>
    if not na(printer.footer)
        row = printer._rTotal - 1
        if printer._maxCol > 0
            // Readjustment: This keeps footer adjusted in a single cell.
            // Note: Gutter (single cell space between each data sets) requires 1 additional column per set.
            //       So on non-stack setup, if gutter is turned on, we have to remove 2 extra spaces from the end to even it out, else 1.
            maxCol = printer.stack ? printer._maxCol : printer._maxCol - (printer.gutterStyle.gutter ?  2 : 1)
            printer._table.clear(0, row, maxCol, row)
            printer._table.merge_cells(0, row, maxCol, row)
        fs = printer.footerStyle
        format = fs.format
        val = printer.footer
        val := not na(format) ? str.format(format, val) : val
        tooltip = __toolTip(printer, 0, row, "footer", printer.footer, _type="string")
        printer._table.cell(0, row, text=val, width=fs.width, height=fs.height, text_color=fs.textColor, text_halign=fs.textHalign, text_valign=fs.textValign, text_size=fs.textSize, bgcolor=fs.bgColor, tooltip=tooltip, text_font_family=fs.textFontFamily)

// Get or set and get table style.
__tableStyle(_printer printer, tableStyle tableStyle=na) =>
    if not na(tableStyle)
        printer.tableStyle := tableStyle
    else if na(printer.tableStyle)
        printer.tableStyle := tableStyle.new()
    printer.tableStyle

// Get or set and get header style.
__headerStyle(_printer printer, headerStyle headerStyle=na) =>
    if not na(headerStyle)
        printer.headerStyle := headerStyle
    else if na(printer.headerStyle)
        printer.headerStyle := headerStyle.new()
    printer.headerStyle

// Get or set and get footer style.
__footerStyle(_printer printer, footerStyle footerStyle=na) =>
    if not na(footerStyle)
        printer.footerStyle := footerStyle
    else if na(printer.footerStyle)
        printer.footerStyle := footerStyle.new()
    printer.footerStyle

// Get or set and get title style.
__titleStyle(_printer printer, titleStyle titleStyle=na) =>
    if not na(titleStyle)
        printer.titleStyle := titleStyle
    else if na(printer.titleStyle)
        printer.titleStyle := titleStyle.new()
    printer.titleStyle     

// Get or set and get key cell style.
__keyCellStyle(_printer printer, cellStyle keyCellStyle=na) =>
    if not na(keyCellStyle)
        printer.keyCellStyle := keyCellStyle
    else if na(printer.keyCellStyle)
        printer.keyCellStyle := cellStyle.new(bgColor=#1E28324D, textColor=#E1E1E1)
    printer.keyCellStyle

// Get or set and get cell style.
__cellStyle(_printer printer, cellStyle cellStyle=na) =>
    if not na(cellStyle)
        printer.cellStyle := cellStyle
    else if na(printer.cellStyle)
        printer.cellStyle := cellStyle.new()
    printer.cellStyle

// Get or set and get gutter style.
__gutterStyle(_printer printer, gutterStyle gutterStyle=na) =>
    if not na(gutterStyle)
        printer.gutterStyle := gutterStyle
    else if na(printer.gutterStyle)
        printer.gutterStyle := gutterStyle.new()
    printer.gutterStyle

// Setup default styles.
__styles(_printer printer) =>
    __tableStyle(printer)
    __headerStyle(printer)
    __footerStyle(printer)
    __titleStyle(printer)
    __keyCellStyle(printer)
    __cellStyle(printer)
    __gutterStyle(printer)

// }

// Backend : {

// Initialize
__init(_printer printer) =>
    if not printer._init
        // Setup all the default styles.
        __styles(printer)
        // Initialize a table.
        var tbl = table.new(printer.loc, printer._cTotal, printer._rTotal, bgcolor=printer.tableStyle.bgColor, frame_color=printer.tableStyle.frameColor, frame_width=printer.tableStyle.frameWidth, border_color=printer.tableStyle.borderColor, border_width=printer.tableStyle.borderWidth)
        printer._table := tbl

    // Header
    if not printer._init and na(printer.header)
        // If header is not given, then starting slot is always column 0, row 0
        printer._slot := "0,0"
    else if not printer._init and not na(printer.header)
        // __header(printer, init=true)
        // After placing the header on very top, change the slot to use row 1, while starting column stays 0.
        printer._slot := "0,1"

    // Footer
    // if not printer._init and not na(printer.footer)
    //     __footer(printer, init=true)  

    // Mark true, so next time init method gets skipped.
    if not printer._init
        printer._init := true
    
// Slot setup
__slot(_printer printer, int col, int row) =>
    // Stacked: (stacking new set of data bottom of previous data set)
    //      Column  - Should not change
    //      Row     - Should increment by 1 
    // Non stacked: (stacking new set of data right side of previous data set)
    //      Column  - Should increment by 1
    //      Row     - Should not change
    int _col = printer.stack ? 0 : col + 1
    int _row = printer.stack ? row + 1 : 0
    // Special case: When not stacked, and have header, row have to start down 1 cell.
    if not printer.stack and not na(printer.header)
        _row += 1
    // Store the value as "col,row" in printer._slot
    printer._slot := str.format("{0},{1}", _col, _row)

// get slot
__slot(_printer printer) =>
    [col, row] = printer._slot._commaSplitPair()
    [tools._int(col), tools._int(row)]

// Add 1 extra cell if title top is not true.
__titleSide(_printer printer, bool title_top) =>
    extraCell = 0
    if not na(title_top)
        extraCell := title_top ? extraCell : 1
    else
        extraCell := printer.titleStyle.top ? extraCell : 1
    extraCell

// Setup max column
__maxColumn(_printer printer, int size, bool title_top, bool horizontal, string _type=na) =>
    // Update the printer._maxCol
    titleSide = __titleSide(printer, title_top)
    if printer.stack and horizontal
        _size = size + titleSide
        // For stacked data sets: (pushed to the bottom)
        // Only if the set of data is positioned horizontally, then max column should be total size of all the values -1 (arrays start at 0 indexed)
        printer._maxCol := _size > printer._maxCol ? _size - 1 : printer._maxCol
    else if printer.stack and not horizontal
        // TODO : the issue is here, fix it
        d2dMaxCol = _type == 'data2d' ? titleSide + 1 : 0
        d3dMaxCol = _type == 'data3d' ? titleSide + (size - 1) : 0
        printer._maxCol := (titleSide > printer._maxCol ? titleSide : printer._maxCol) 
        printer._maxCol := (d2dMaxCol > printer._maxCol ? d2dMaxCol : printer._maxCol)
        printer._maxCol := (d3dMaxCol > printer._maxCol ? d3dMaxCol : printer._maxCol)
        printer._maxCol
    else if not printer.stack
        // For non-stacked data sets: (pushed to the right)
        // every set of data occupies a column therefore +1.
        // And if gutter is turned on, that also adds +1 (therefore 2).
        // And if title is placed on the side (not top) then +1 as well.
        printer._maxCol += (printer.gutterStyle.gutter ? 2 : 1) + titleSide + (_type == 'data2d' and not horizontal ? 1 : 0) + (_type == 'data3d' and not horizontal ? size - 1 : 0)
        if horizontal
            // And if the set of data is positioned horizontally, then max column should be total size of all the values -1 (arrays start at 0 indexed)
            printer._maxCol += (size - 1)

__startPrinter(_printer printer, title, titleStyle, size, horizontal, string _type=na) =>
    // Get the printer._init value to test first run.
    firstRun = printer._init ? false : true
    // Only runs when print is called first time.
    __init(printer)
    // Get the column and row values from printer._slot. Print will start from here.
    [col, row] = __slot(printer)
    // Gutter
    ps = printer.gutterStyle
    if ps.gutter
        tooltip = __toolTip(printer, col, row, "gutter", "")
        printer._table.cell(col, row, na, width=ps.width, height=ps.height, tooltip=tooltip)
    // Return the column and row value.
    if not firstRun and ps.gutter
        col := printer.stack ? col : (firstRun ? col : col + 1)
        row := printer.stack ? (firstRun ? row : row + 1) : row
    // Title setup
    if not na(title)
        format = titleStyle.format
        tooltip = __toolTip(printer, col, row, "title", title)
        val = not na(format) ? str.format(format, title) : tools._str(title)
        printer._table.cell(col, row, text=val, width=titleStyle.width, height=titleStyle.height, text_color=titleStyle.textColor, text_halign=titleStyle.textHalign, text_valign=titleStyle.textValign, text_size=titleStyle.textSize, bgcolor=titleStyle.bgColor, tooltip=tooltip, text_font_family=titleStyle.textFontFamily)
        
        exp01 = size > 1 and titleStyle.top and horizontal
        exp02 = size > 1 and not titleStyle.top and not horizontal
        exp03 = _type == 'data2d' and not titleStyle.top and horizontal
        exp04 = _type == 'data2d' and titleStyle.top and not horizontal
        exp05 = _type == 'data3d' and not titleStyle.top and horizontal
        exp06 = _type == 'data3d' and titleStyle.top and not horizontal

        switch 
            exp01 or exp06 => printer._table.merge_cells(col, row, col + (size - 1), row)
            exp02 or exp05 => printer._table.merge_cells(col, row, col, row + (size - 1))
            exp03 => printer._table.merge_cells(col, row, col, row + 1)
            exp04 => printer._table.merge_cells(col, row, col + 1, row)

        row += titleStyle.top ? 1 : 0
        col += titleStyle.top ? 0 : 1
    [col, row]

// End the printer process
__endPrinter(_printer printer, col, row, size, titleTop, horizontal, string _type=na) =>
    // After the loop completes, update the printer._slot with the last used column and row value
    __slot(printer, col, row)
    // Update the printer._maxCol
    __maxColumn(printer, size, titleTop, horizontal, _type)
    // Re-run the title and footer, incase they need rearrangement for cell merging.
    // Only runs if either title and/or footer is available.
    __header(printer)
    __footer(printer)
    // Finally return the printer object.
    printer

// }

// Loops : {

__getValColors(val, cellStyle cs, cellStyle kcs=na, bool dynamicKey=false) =>
    bgColor = __getBgColor(val, cs)
    txtColor = __getTextColor(val, cs)
    valColors = array.from(bgColor, txtColor)
    if dynamicKey
        valColors.push(__getBgColor(val, kcs))
        valColors.push(__getTextColor(val, kcs))
    valColors

__getDvColors(dv dv, cellStyle cs, cellStyle kcs=na, bool dynamicKey=false) =>
    valColors = array.new<color>()
    switch dv._type
        'string' =>
            val = dv.stringValue
            valColors := __getValColors(val, cs, kcs, dynamicKey)
        'float' => 
            val = dv.floatValue
            valColors := __getValColors(val, cs, kcs, dynamicKey)
        'int' => 
            val = dv.intValue
            valColors := __getValColors(val, cs, kcs, dynamicKey)
        'bool' => 
            val = dv.boolValue
            valColors := __getValColors(val, cs, kcs, dynamicKey)
        'color' => 
            val = dv.colorValue
            valColors := __getValColors(val, cs, kcs, dynamicKey)
    valColors

// Loop thru array values.
__arrayPrintLoop(_printer printer, values, title, titleStyle, cellStyle, string _type=na, dvs dynamicValues=na) =>
    _tp = not na(_type) ? _type : tools._type(values) 
    // Size of the values.
    int size = values.size()
    // Start the process.
    ts = na(titleStyle) ? __titleStyle(printer) : titleStyle
    cs = na(cellStyle) ? __cellStyle(printer) : cellStyle
    [col, row] = __startPrinter(printer, title, ts, size, cs.horizontal)
    // We need to store the column and row values into temporary variables.
    // These temporary variables, allow us to keep track of current changes.
    int _col = col 
    int _row = row
    // dynamic value check
    dvExist = not na(dynamicValues) ? (dynamicValues.dvsArr.size() == size ? true : false) : false
    // Start the loop thru the values.
    for i=0 to size - 1
        if cs.horizontal
            // If horizontal is true, values should be placed per column.
            // Therefore, each values should get an incremental column value.
            _col := col + i
        else 
            // If horizontal is false, values should be placed per row.
            // Therefore, each values should get an incremental row value.
            _row := row + i
        vl = values.get(i)
        _bgColor = __getBgColor(vl, cs)
        _txtColor = __getTextColor(vl, cs)
        if dvExist
            getDvColors = __getDvColors(dynamicValues.dvsArr.get(i), cs)
            _bgColor := getDvColors.get(0)
            _txtColor := getDvColors.get(1)
        _index = str.startswith(_tp, "array") ? i : na 
        tooltip = __toolTip(printer, _col, _row, "cell", tools._str(vl), idx=_index, _type=_tp)
        // Finally, put them in a table cell.
        printer._table.cell(_col, _row, text=__getCellFormatStr(vl, cs), width=cs.width, height=cs.height, text_color=_txtColor, text_halign=cs.textHalign, text_valign=cs.textValign, text_size=cs.textSize, bgcolor=_bgColor, tooltip=tooltip, text_font_family=cs.textFontFamily)
    // End printer process.
    tTop = na(title) ? true : ts.top
    __endPrinter(printer, _col, _row, size, tTop, cs.horizontal)

// Loop thru matrix values.
__matrixPrintLoop(_printer printer, values, title, titleStyle, cellStyle, dvs dynamicValues=na) =>
    _tp = tools._type(values)
    // Start the process
    totalRows = values.rows()
    totalCols = values.columns()
    ts = na(titleStyle) ? __titleStyle(printer) : titleStyle
    size = ts.top ? totalCols : totalRows
    horz = ts.top ? true : false
    [col, row] = __startPrinter(printer, title, ts, size, horz)
    // We need to store the column and row values into temporary variables.
    // These temporary variables, allow us to keep track of current changes.
    int _col = col 
    int _row = row
    // dynamic value check
    dvExist = not na(dynamicValues) ? (dynamicValues.dvsMx.rows() == totalRows and dynamicValues.dvsMx.columns() == totalCols ? true : false) : false
    // Start the loop thru the values.
    cs = na(cellStyle) ? __cellStyle(printer) : cellStyle
    for r=0 to totalRows - 1
        for c=0 to totalCols - 1
            _col := col + c
            _row := row + r
            vl = values.get(r, c)
            _bgColor =  __getBgColor(vl, cs)
            _txtColor = __getTextColor(vl, cs)
            if dvExist
                getDvColors = __getDvColors(dynamicValues.dvsMx.get(r, c), cs)
                _bgColor := getDvColors.get(0)
                _txtColor := getDvColors.get(1)
            tooltip = __toolTip(printer, _col, _row, "cell", tools._str(vl), mCol=c, mRow=r, _type=_tp)
            printer._table.cell(_col, _row, text=__getCellFormatStr(vl, cs), width=cs.width, height=cs.height, text_color=_txtColor, text_halign=cs.textHalign, text_valign=cs.textValign, text_size=cs.textSize, bgcolor=_bgColor, tooltip=tooltip, text_font_family=cs.textFontFamily)
    tTop = na(title) ? true : ts.top
    __endPrinter(printer, _col, _row, totalCols, tTop, true)

// }

// Printer Methods : {

// @function            Print data on screen.
// @param this          (_printer) A _printer UDT object. 
// @param values        Data to print on screen. Possible types: string, float, int, bool, color, array<type>, matrix<type> 
// @param dynamicValues Use this value for dynamic color use. A `cellStyle` object with `dynamicColor` object must be present.
// @param title         (string) A title for the value. (`na` is used if no argument is supplied). 
// @param titleStyle    (titleStyle) Add a custom `titleStyle` for this print only. (`na` is used if no argument is supplied). 
// @param cellStyle     (cellStyle) Add a custom `cellStyle` for this print only. Pass `dynamicColor` object to add dynamic coloring. (`na` is used if no argument is supplied).
// @param theme         (string) The name of the theme. Choices: gray, blue, green, orange, green, red, purple, pink and white. (`na` is used if no argument is supplied).
// @returns             (_printer) Returns the _printer UDT object.
export method print(_printer this, string values, dv dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    dvs _dvs =  not na(dynamicValues) ? dvs.new(dvsArr=array.from(dynamicValues)) : na
    __arrayPrintLoop(printer = this, values = array.new_string(1, values), title = title, titleStyle = ts, cellStyle = cs, _type = "string", dynamicValues = _dvs)

export method print(_printer this, float values, dv dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    dvs _dvs =  not na(dynamicValues) ? dvs.new(dvsArr=array.from(dynamicValues)) : na
    __arrayPrintLoop(printer = this, values = array.new_float(1, values), title = title, titleStyle = ts, cellStyle = cs, _type = "float", dynamicValues = _dvs)

export method print(_printer this, int values, dv dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    dvs _dvs =  not na(dynamicValues) ? dvs.new(dvsArr=array.from(dynamicValues)) : na
    __arrayPrintLoop(printer = this, values = array.new_int(1, values), title = title, titleStyle = ts, cellStyle = cs, _type = "int", dynamicValues = _dvs)

export method print(_printer this, bool values, dv dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    dvs _dvs =  not na(dynamicValues) ? dvs.new(dvsArr=array.from(dynamicValues)) : na
    __arrayPrintLoop(printer = this, values = array.new_bool(1, values), title = title, titleStyle = ts, cellStyle = cs, _type = "bool", dynamicValues = _dvs)

export method print(_printer this, color values, dv dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    dvs _dvs =  not na(dynamicValues) ? dvs.new(dvsArr=array.from(dynamicValues)) : na
    __arrayPrintLoop(printer = this, values = array.new_color(1, values), title = title, titleStyle = ts, cellStyle = cs, _type = "color", dynamicValues = _dvs)

// Arrays
export method print(_printer this, array<string> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __arrayPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)

export method print(_printer this, array<float> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __arrayPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)
    
export method print(_printer this, array<int> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __arrayPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)
    
export method print(_printer this, array<bool> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __arrayPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)
    
export method print(_printer this, array<color> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __arrayPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)

// Matrix
export method print(_printer this, matrix<string> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __matrixPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)
    
export method print(_printer this, matrix<float> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __matrixPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)

export method print(_printer this, matrix<int> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __matrixPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)
    
export method print(_printer this, matrix<bool> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __matrixPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)

export method print(_printer this, matrix<color> values, dvs dynamicValues=na, string title=na, titleStyle titleStyle=na, cellStyle cellStyle=na, string theme=na) =>
    [ts, cs, _, _] = ___printThemeSetup(this, theme, titleStyle, cellStyle)
    __matrixPrintLoop(printer = this, values = values, title = title, titleStyle = ts, cellStyle = cs, dynamicValues = dynamicValues)

// @function            Set a printer header. Optionally pass a customized header style.
// @param this          (_printer) A _printer UDT object.  
// @param val           (string) A header string. 
// @param headerStyle   (headerStyle) Add a custom `headerStyle` for the printer object. (`na` is used if no argument is supplied). 
// @returns             (_printer) Returns the _printer UDT object.
export method header(_printer this, string val, headerStyle headerStyle=na) =>
    __init(this)
    __headerStyle(this, headerStyle)
    this.header := val
    this

// @function            Set a printer footer. Optionally pass a customized footer style.
// @param this          (_printer) A _printer UDT object. 
// @param val           (string) A footer string. 
// @param footerStyle   (footerStyle) Add a custom `footerStyle` for the printer object. (`na` is used if no argument is supplied). 
// @returns             (_printer) Returns the _printer UDT object.
export method footer(_printer this, string val, footerStyle footerStyle=na) =>
    __init(this)
    __footerStyle(this, footerStyle)
    this.footer := val
    this

// @function            Set a printer's default title location.
// @param this          (_printer) A _printer UDT object. 
// @param top           (bool) Location to place data titles. Use `false` to place the title to the left of data, or `true` to place title on top of data. By default this title top is `true`. 
// @returns             (_printer) Returns the _printer UDT object.
export method title(_printer this, bool top) =>
    __init(this)
    __titleStyle(this)
    this.titleStyle.top := top
    this

// @function            Set a printer's custom title style.
// @param this          (_printer) A _printer UDT object. 
// @param titleStyle    (titleStyle) Add a custom `titleStyle` for the printer object. (`na` is used if no argument is supplied).  
// @returns             (_printer) Returns the _printer UDT object.
export method title(_printer this, titleStyle titleStyle) =>
    __init(this)
    __titleStyle(this, titleStyle)
    this

// @function            Set a printer's array orientation.
// @param this          (_pr    inter) A _printer UDT object.
// @param horizontal    (bool) Array orientation. Use `false` for vertical placement, or `true` to use horizontal placement. By default horizontal is `false`. 
// @returns             (_printer) Returns the _printer UDT object.
export method cell(_printer this, bool horizontal) =>
    __init(this)
    __cellStyle(this)
    this.cellStyle.horizontal := horizontal
    this

// @function            Set a printer's custom style for all data cells (excludes: header, footer and titles).
// @param this          (_printer) A _printer UDT object.
// @param cellStyle     (cellStyle) Add a custom `cellStyle` for the printer object.  
// @returns             (_printer) Returns the _printer UDT object.
export method cell(_printer this, cellStyle cellStyle) =>
    __init(this)
    __cellStyle(this, cellStyle)
    this

// @function            Set a printer's stacking order. Stacking order is the placement order of each new data sets. Either set new data under (true), or to the right (false).
// @param this          (_printer) A _printer UDT object.
// @param stack         (bool) If set to `true`, following data will be stacked under, if `false`, data will be pushed to the right. By default stacking is`true`. 
// @returns             (_printer) Returns the _printer UDT object.
export method stack(_printer this, bool stack) =>
    __init(this)
    this.stack := stack
    this

// @function            Set a printer's gutter. A gutter is an empty cell spacing between two individual printed data. 
// @param this          (_printer) A _printer UDT object. 
// @param gutter        (bool) If set to `true`, an empty cell will be added between each data set, if `false`, data sets will have no separation. By default gutter is `true`. 
// @returns             (_printer) Returns the _printer UDT object.
export method gutter(_printer this, bool gutter) =>
    __init(this)
    __gutterStyle(this)
    this.gutterStyle.gutter := gutter
    this

// @function            Set a printer's custom style for gutter cells.
// @param this          (_printer) A _printer UDT object.
// @param gutterStyle   (cellStyle) Add a custom `gutterStyle` for the printer object.  
// @returns             (_printer) Returns the _printer UDT object.
export method gutter(_printer this, gutterStyle gutterStyle) =>
    __init(this)
    __gutterStyle(this, gutterStyle)
    this

// @function            Set the debug value for a printer.
// @param this          (_printer) A _printer UDT object.
// @param gutterStyle   (bool) If set to `true`, there will be some debug info added to the tooltip for each printed cell (hover ur mouse over to see). If `false` this extra info will stay hidden. By default debug is `false`.  
// @returns             (_printer) Returns the _printer UDT object.
export method debug(_printer this, bool debug) =>
    __init(this)
    this.debug := debug
    this


// @function            Create a new printer object.
// @param header        (string) A header string for the printer object. (`na` is used if no argument is supplied).
// @param footer        (string) A footer string for the printer object. (`na` is used if no argument is supplied).
// @param stack         (bool) When set to true, every `print()` method will stack new data under the previous set. (`true` is used if no argument is supplied).
// @param loc           (string) Set the location of the printer object on screen. (`position.middle_center` is used if no argument is supplied).
// @param tableStyle    (tableStyle) A `tableStyle` object for targetting the table object. (`na` is used if no argument is supplied).
// @param headerStyle   (headerStyle) A `headerStyle` object for targetting the printer's header cell. (`na` is used if no argument is supplied).
// @param footerStyle   (footerStyle) A `footerStyle` object for targetting the printer's footer cell. (`na` is used if no argument is supplied).
// @param titleStyle    (titleStyle) A `titleStyle` object for targetting all title cells. (`na` is used if no argument is supplied).
// @param keyCellStyle  (keyCellStyle) A `keyCellStyle` object for targetting all 'key' cells (applies for only multidatas). (`na` is used if no argument is supplied).
// @param cellStyle     (cellStyle) A `cellStyle` object for targetting all regular cells. (`na` is used if no argument is supplied).
// @param gutterStyle   (gutterStyle) A `gutterStyle` object for targetting the space between each set of data. (`na` is used if no argument is supplied).
// @param theme         (string) Set a color theme for the printer object using pre-defined theme names. Choices: gray, blue, green, orange, red, purple, pink and white. Gray is always default. (`na` is used if no argument is supplied).
// @param debug         (bool) If set to `true`, there will be some debug info added to the tooltip for each printed cell (hover ur mouse over to see). (`false` is used if no argument is supplied).
// @returns             (_printer) Returns a new _printer UDT object.
export printer(string header=na, string footer=na, bool stack = true, string loc = position.middle_center, 
  tableStyle tableStyle=na, headerStyle headerStyle=na, footerStyle footerStyle=na, titleStyle titleStyle=na, 
  cellStyle keyCellStyle=na, cellStyle cellStyle=na, gutterStyle gutterStyle=na, string theme=na, bool debug = false) =>
    printer = _printer.new(header, footer, stack, loc, debug)
    __tableStyle(printer, tableStyle)
    __headerStyle(printer, headerStyle)
    __footerStyle(printer, footerStyle)
    __titleStyle(printer, titleStyle)
    __keyCellStyle(printer, keyCellStyle)
    __cellStyle(printer, cellStyle)
    __gutterStyle(printer, gutterStyle)
    if not na(theme)
        printer.theme(theme)
    printer

// }

// For MULTIDATA library - Printer Extension : {

export type _kvs
    array<string> keys
    array<string> values
    array<string> types

export type _pkvs
    array<string> primaryKeys
    array<_kvs> kvss

// Loop thru key-value arrays (data2d).
__data2dPrintLoop(_printer printer, kvs, title, titleStyle, cellStyle, keyCellStyle, map<string, dvs> dynamicValues, bool dynamicKey) =>
    _tp = 'data2d'
    // Size of the values.
    // Start the process.
    ts = na(titleStyle) ? __titleStyle(printer) : titleStyle
    cs = na(cellStyle) ? __cellStyle(printer) : cellStyle
    kcs = na(keyCellStyle) ? __keyCellStyle(printer) : keyCellStyle
    int size = kvs.keys.size()
    _size = cs.horizontal ? size : (not na(title) and not na(ts.top) ? size : 2)
    [col, row] = __startPrinter(printer, title, ts, _size, cs.horizontal, _tp)
    // We need to store the column and row values into temporary variables.
    // These temporary variables, allow us to keep track of current changes.
    int _valCol = cs.horizontal ? col : col + 1
    int _valRow = cs.horizontal ? row + 1 : row
    
    _bgColor = cs.bgColor
    _txtColor = cs.textColor
    string formatted_vl = na

    // Start the loop thru the values.
    for i=0 to size - 1
        _keyCol = cs.horizontal ? col + i : col
        _keyRow = cs.horizontal ? row : row + i
        _valCol := cs.horizontal ? col + i : _valCol
        _valRow := cs.horizontal ? _valRow : row + i
        ky = kvs.keys.get(i)
        __tp = kvs.types.get(i)
        _keyBgColor = __getBgColor(ky, kcs)
        _keyTxtColor = __getTextColor(ky, kcs)

        // If dynamicValues for keys are available, and dynamicKey is not true, 
        // use the dynamicValues for coloring the key cells.
        if dynamicValues.contains('key') and not dynamicKey
            getDvColors = __getDvColors(dynamicValues.get('key').dvsArr.get(i), kcs)
            _keyBgColor := getDvColors.get(0)
            _keyTxtColor := getDvColors.get(1)

        // If dynamicValues are available for values, color the value cells using them. If dynamicKey is true,
        // then also color key cells with these values.
        dvExist = dynamicValues.contains('val')
        if dvExist
            getDvColors = __getDvColors(dynamicValues.get('val').dvsArr.get(i), cs, kcs, dynamicKey)
            _bgColor := getDvColors.get(0)
            _txtColor := getDvColors.get(1)
            if dynamicKey
                _keyBgColor := getDvColors.get(2)
                _keyTxtColor := getDvColors.get(3)
        
        // For regular values:
        // If dynamicValues were not available, then cell coloring happens with existing values.
        // If dynamicKey is true, then color key cell using these values as well.
        switch __tp
            'float' =>
                vl = tools._float(kvs.values.get(i))
                formatted_vl := __getCellFormatStr(vl, cs)
                if not dvExist
                    valColors = __getValColors(vl, cs, kcs, dynamicKey)
                    _bgColor := valColors.get(0)
                    _txtColor := valColors.get(1)
                    if dynamicKey
                        _keyBgColor := valColors.get(2)
                        _keyTxtColor := valColors.get(3)
            'int' =>
                vl = tools._int(kvs.values.get(i))
                formatted_vl := __getCellFormatStr(vl, cs)
                if not dvExist
                    valColors = __getValColors(vl, cs, kcs, dynamicKey)
                    _bgColor := valColors.get(0)
                    _txtColor := valColors.get(1)
                    if dynamicKey
                        _keyBgColor := valColors.get(2)
                        _keyTxtColor := valColors.get(3)
            'bool' =>
                vl = tools._bool(kvs.values.get(i))
                formatted_vl := __getCellFormatStr(vl, cs)
                if not dvExist
                    valColors = __getValColors(vl, cs, kcs, dynamicKey)
                    _bgColor := valColors.get(0)
                    _txtColor := valColors.get(1)
                    if dynamicKey
                        _keyBgColor := valColors.get(2)
                        _keyTxtColor := valColors.get(3)
            'color' =>
                vl = tools._clr(kvs.values.get(i))
                formatted_vl := __getCellFormatStr(vl, cs)
                if not dvExist
                    valColors = __getValColors(vl, cs, kcs, dynamicKey)
                    _bgColor := valColors.get(0)
                    _txtColor := valColors.get(1)
                    if dynamicKey
                        _keyBgColor := valColors.get(2)
                        _keyTxtColor := valColors.get(3)
            =>
                vl = kvs.values.get(i)
                formatted_vl := __getCellFormatStr(vl, cs)
                if not dvExist
                    valColors = __getValColors(vl, cs, kcs, dynamicKey)
                    _bgColor := valColors.get(0)
                    _txtColor := valColors.get(1)
                    if dynamicKey
                        _keyBgColor := valColors.get(2)
                        _keyTxtColor := valColors.get(3)

        keyTooltip = __toolTip(printer, _keyCol, _keyRow, "key", ky, keyIdx=i, _type='string')
        valTooltip = __toolTip(printer, _valCol, _valRow, "cell", kvs.values.get(i), key=ky, _type=__tp)
        // Finally, put them in a table cell.
        // keys
        printer._table.cell(_keyCol, _keyRow, text=ky, width=kcs.width, height=kcs.height, text_color=_keyTxtColor, text_halign=kcs.textHalign, text_valign=kcs.textValign, text_size=kcs.textSize, bgcolor=_keyBgColor, tooltip=keyTooltip, text_font_family=kcs.textFontFamily)
        // Values
        printer._table.cell(_valCol, _valRow, text=formatted_vl, width=cs.width, height=cs.height, text_color=_txtColor, text_halign=cs.textHalign, text_valign=cs.textValign, text_size=cs.textSize, bgcolor=_bgColor, tooltip=valTooltip, text_font_family=cs.textFontFamily)
    // End printer process.
    tTop = na(title) ? true : ts.top
    _size := cs.horizontal ? size : 2
    __endPrinter(printer, _valCol, _valRow, _size, tTop, cs.horizontal, _tp)

// Loop thru key-value arrays (data2d).
__data3dPrintLoop(_printer printer, pkvs, title, titleStyle, cellStyle, map<string, cellStyle> styles, map<string, dvs> dynamicValues, string dynamicKey) =>
    _tp = 'data3d'
    // Start the process.
    ts = na(titleStyle) ? __titleStyle(printer) : titleStyle
    cs = na(cellStyle) ? __cellStyle(printer) : cellStyle
    dkcs = styles.contains('dk') ? styles.get('dk') : __keyCellStyle(printer)
    pkcs = styles.contains('pk') ? styles.get('pk') : __keyCellStyle(printer)

    // keys
    primaryKeys  = pkvs.primaryKeys
    dataKeys     = pkvs.kvss.get(0).keys
    dataKeyTypes = pkvs.kvss.get(0).types

    // sizes
    int pkSize = primaryKeys.size()
    int dkSize = dataKeys.size()
    int totalRows = cs.horizontal ? pkSize : dkSize
    int totalCols = cs.horizontal ? dkSize : pkSize

    rowKeys = cs.horizontal ? primaryKeys : dataKeys
    colKeys = cs.horizontal ? dataKeys : primaryKeys

    int size = ts.top ? (cs.horizontal ? dkSize + 1 : pkSize + 1) : (cs.horizontal ? pkSize + 1 : dkSize + 1)
    [col, row] = __startPrinter(printer, title, ts, size, cs.horizontal, _tp)
    int _valCol = na
    int _valRow = na

    _bgColor = cs.bgColor
    _txtColor = cs.textColor
    _pkBgColor = pkcs.bgColor
    _pkTxtColor = pkcs.textColor
    _dkBgColor = dkcs.bgColor
    _dkTxtColor = dkcs.textColor
    string formatted_vl = na

    // Print values
    for [pk_idx, pk] in primaryKeys
        // primary keys
        _pkCol = cs.horizontal ? col : col + 1 + pk_idx
        _pkRow = cs.horizontal ? row + 1 + pk_idx : row
        _pkBgColor := __getBgColor(pk, pkcs)
        _pkTxtColor := __getTextColor(pk, pkcs)

        // If dynamicValues for primary keys are available, and dynamicKey is not set, 
        // use the dynamicValues for coloring the primary key cells.
        if dynamicValues.contains('pk') and na(dynamicKey)
            getDvColors = __getDvColors(dynamicValues.get('pk').dvsArr.get(pk_idx), pkcs)
            _pkBgColor := getDvColors.get(0)
            _pkTxtColor := getDvColors.get(1)
        
        pkTooltip = __toolTip(printer, _pkCol, _pkRow, "primary key", tools._str(pk), pkIdx=pk_idx, _type='string')
        printer._table.cell(_pkCol, _pkRow, text=pk, width=pkcs.width, height=pkcs.height, text_color=_pkTxtColor, text_halign=pkcs.textHalign, text_valign=pkcs.textValign, text_size=pkcs.textSize, bgcolor=_pkBgColor, tooltip=pkTooltip, text_font_family=pkcs.textFontFamily)
        for [dk_idx, dk] in dataKeys
            _cs = styles.contains(dk) ? styles.get(dk) : cs

            // data keys
            if pk_idx == 0
                _dkCol = cs.horizontal ? col + 1 + dk_idx : col
                _dkRow = cs.horizontal ? row : row + 1 + dk_idx
                _dkBgColor := __getBgColor(dk, dkcs)
                _dkTxtColor := __getTextColor(dk, dkcs)

                // If dynamicValues for data keys are available, use the dynamicValues for coloring the data key cells.
                if dynamicValues.contains('dk')
                    getDvColors = __getDvColors(dynamicValues.get('dk').dvsArr.get(dk_idx), dkcs)
                    _dkBgColor := getDvColors.get(0)
                    _dkTxtColor := getDvColors.get(1)

                dkTooltip = __toolTip(printer, _dkCol, _dkRow, "data key", tools._str(dk), dkIdx=dk_idx, _type='string')
                printer._table.cell(_dkCol, _dkRow, text=dk, width=dkcs.width, height=dkcs.height, text_color=_dkTxtColor, text_halign=dkcs.textHalign, text_valign=dkcs.textValign, text_size=dkcs.textSize, bgcolor=_dkBgColor, tooltip=dkTooltip, text_font_family=dkcs.textFontFamily)
    
            // values
            _valCol := col + 1 + (cs.horizontal ? dk_idx : pk_idx)
            _valRow := row + 1 + (cs.horizontal ? pk_idx : dk_idx)

            __tp = dataKeyTypes.get(dk_idx)

            // If dynamicValues are available for values, color the value cells using them. If dynamicKey is set,
            // then also color primary key cells with these values.
            dvExist = dynamicValues.contains(dk)
            if dvExist
                isDynamicKey = dynamicKey == dk
                getDvColors = __getDvColors(dynamicValues.get(dk).dvsArr.get(pk_idx), _cs, pkcs, isDynamicKey)
                _bgColor := getDvColors.get(0)
                _txtColor := getDvColors.get(1)
                if isDynamicKey
                    printer._table.cell_set_bgcolor(_pkCol, _pkRow, getDvColors.get(2))
                    printer._table.cell_set_text_color(_pkCol, _pkRow, getDvColors.get(3))

            // For regular values:
            // If dynamicValues were not available, then cell coloring happens with existing values.
            // If dynamicKey is true, then color key cell using these values as well.
            switch __tp
                'float' =>
                    vl = tools._float(pkvs.kvss.get(pk_idx).values.get(dk_idx))
                    formatted_vl := __getCellFormatStr(vl, _cs)
                    if na(dynamicValues) or not dvExist
                        isDynamicKey = dynamicKey == dk
                        valColors = __getValColors(vl, cs, pkcs, isDynamicKey)
                        _bgColor := valColors.get(0)
                        _txtColor := valColors.get(1)
                        if isDynamicKey
                            printer._table.cell_set_bgcolor(_pkCol, _pkRow, valColors.get(2))
                            printer._table.cell_set_text_color(_pkCol, _pkRow, valColors.get(3))
                'int' =>
                    vl = tools._int(pkvs.kvss.get(pk_idx).values.get(dk_idx))
                    formatted_vl := __getCellFormatStr(vl, _cs)
                    if na(dynamicValues) or not dvExist
                        isDynamicKey = dynamicKey == dk
                        valColors = __getValColors(vl, cs, pkcs, isDynamicKey)
                        _bgColor := valColors.get(0)
                        _txtColor := valColors.get(1)
                        if isDynamicKey
                            printer._table.cell_set_bgcolor(_pkCol, _pkRow, valColors.get(2))
                            printer._table.cell_set_text_color(_pkCol, _pkRow, valColors.get(3))
                'bool' =>
                    vl = tools._bool(pkvs.kvss.get(pk_idx).values.get(dk_idx))
                    formatted_vl := __getCellFormatStr(vl, _cs)
                    if na(dynamicValues) or not dvExist
                        isDynamicKey = dynamicKey == dk
                        valColors = __getValColors(vl, cs, pkcs, isDynamicKey)
                        _bgColor := valColors.get(0)
                        _txtColor := valColors.get(1)
                        if isDynamicKey
                            printer._table.cell_set_bgcolor(_pkCol, _pkRow, valColors.get(2))
                            printer._table.cell_set_text_color(_pkCol, _pkRow, valColors.get(3))
                'color' =>
                    vl = tools._clr(pkvs.kvss.get(pk_idx).values.get(dk_idx))
                    formatted_vl := __getCellFormatStr(vl, _cs)
                    if na(dynamicValues) or not dvExist
                        isDynamicKey = dynamicKey == dk
                        valColors = __getValColors(vl, cs, pkcs, isDynamicKey)
                        _bgColor := valColors.get(0)
                        _txtColor := valColors.get(1)
                        if isDynamicKey
                            printer._table.cell_set_bgcolor(_pkCol, _pkRow, valColors.get(2))
                            printer._table.cell_set_text_color(_pkCol, _pkRow, valColors.get(3))
                =>
                    vl = pkvs.kvss.get(pk_idx).values.get(dk_idx)
                    formatted_vl := __getCellFormatStr(vl, _cs)
                    if na(dynamicValues) or not dvExist
                        isDynamicKey = dynamicKey == dk
                        valColors = __getValColors(vl, cs, pkcs, isDynamicKey)
                        _bgColor := valColors.get(0)
                        _txtColor := valColors.get(1)
                        if isDynamicKey
                            printer._table.cell_set_bgcolor(_pkCol, _pkRow, valColors.get(2))
                            printer._table.cell_set_text_color(_pkCol, _pkRow, valColors.get(3))
                
            valTooltipVal = __toolTip(printer, _valCol, _valRow, "cell", pkvs.kvss.get(pk_idx).values.get(dk_idx), pk=pk, dk=dk, _type=__tp)
            // Finally, put them in a table cell.
            printer._table.cell(_valCol, _valRow, text=formatted_vl, width=cs.width, height=cs.height, text_color=_txtColor, text_halign=cs.textHalign, text_valign=cs.textValign, text_size=cs.textSize, bgcolor=_bgColor, tooltip=valTooltipVal, text_font_family=cs.textFontFamily)

    // End printer process.
    size := cs.horizontal ? dkSize + 1 : pkSize + 1
    tTop = na(title) ? true : ts.top
    __endPrinter(printer, _valCol, _valRow, size, tTop, cs.horizontal, _tp)

export method print2d(_printer this, _kvs kvs, string title=na, titleStyle titleStyle=na, map<string, cellStyle> styles=na, string theme=na, map<string, dvs> dynamicValues=na, bool dynamicKey=false) =>
    _styles = na(styles) ? map.new<string, cellStyle>() : styles
    _dynamicValues = na(dynamicValues) ? map.new<string, dvs>() : dynamicValues
    cellStyle _cs = _styles.contains('val') ? styles.get('val') : na
    cellStyle _kcs = _styles.contains('key') ? styles.get('key') : na
    [ts, cs, kcs, _] = ___printThemeSetup(this, theme, titleStyle, _cs, _kcs)
    __data2dPrintLoop(printer=this, kvs=kvs, title=title, titleStyle=ts, cellStyle=cs, keyCellStyle=_kcs, dynamicValues=_dynamicValues, dynamicKey=dynamicKey)

export method print3d(_printer this, _pkvs pkvs, string title=na, titleStyle titleStyle=na, map<string, cellStyle> styles=na, string theme=na, map<string, dvs> dynamicValues=na, string dynamicKey=na) =>
    _styles = na(styles) ? map.new<string, cellStyle>() : styles
    _dynamicValues = na(dynamicValues) ? map.new<string, dvs>() : dynamicValues
    cellStyle _cs = _styles.contains('val') ? styles.get('val') : na
    cellStyle _pkcs = _styles.contains('pk') ? styles.get('pk') : na
    cellStyle _dkcs = _styles.contains('dk') ? styles.get('dk') : na
    [ts, cs, pkcs, dkcs] = ___printThemeSetup(this, theme, titleStyle, _cs, _pkcs, _dkcs)
    __data3dPrintLoop(printer=this, pkvs=pkvs, title=title, titleStyle=ts, cellStyle=cs, styles=_styles, dynamicValues=_dynamicValues, dynamicKey=dynamicKey)

// }

var header = "Printer: faiyaz7283.github.io/tools/printer"
var footer = "Full documentation: faiyaz7283.github.io/tools/printer"
var docSec1a = "Use the convenient _printer object and print method to print almost anything on screen.\nPrinter object can print a single item or multiple sets of data at once.\nBehind the scene, it uses table, and cells strategically for printing.\nAll _printer methods are chain-able for convenience."
var docSec1b = "Header: Use the convenient header method to add a header, and pass a headerStyle object to customize."
var docSec1c = "Footer: Use the convenient footer method to add a footer, and pass a footerStyle object to customize."
var docSec1d = "There's also several other convenient methods to customize the printer.\n- theme(): method to add a preset theme.\n   Choices are gray (same as default color style), blue, orange, green, red, purple, pink, yellow and white.\n- title(): pass custom default titleStyle object for all data,\n   or just pass top=<true/false> to designate the location of title placement.\n- stack(): use true or false to either stack each set of data (default is true), or side by side (if false).\n- gutter(): use true or false to add extra spacing. Pass a gutterStyle object to customize.\n- cell(): method to add custom default cell settings with cellStyle object,\n   or just pass horizontal=<true/false> to position array data vertically or horizontally.\n- debug(): use true or false, to print some helpful debugging info or hide them."
var docSec1e = "Once a printer object is created, use the print() method to print any item on screen.\nEach print method accepts a title parameter for that particular dataset.\nYou can also pass titleStyle and cellStyle objects to individually target that dataset.\nYou can also pass a theme name to individual print methods."
var docSec1 = array.from(docSec1a, docSec1b, docSec1c, docSec1d, docSec1e)

var hs = headerStyle.new(textSize=size.large)
var fs = footerStyle.new(textSize=size.large, textHalign=text.align_right)
var ts = titleStyle.new(top=false, textHalign=text.align_right, textValign=text.align_center, textSize=size.normal)
var cs = cellStyle.new(horizontal=false, textHalign=text.align_left, textSize=size.normal)

// if barstate.islast
//     printer = printer(header=header, footer=footer, headerStyle=hs, footerStyle=fs, titleStyle=ts, cellStyle=cs, theme='orange', debug=true)

//     printer.print(docSec1)


// TESTING : {

var dataKeys = array.from('High', 'Low', 'Long', 'Size', 'Comment', 'Random', 'Color')
var primaryKeys = array.from('TSLA', 'AAPL', 'NVDA', 'MSFT', 'AMZN')
var types = array.from('float', 'float', 'bool', 'int', 'string', 'float', 'color')
var tsla_vals = array.from('278.79', '190.02', 'true', '1100', 'up', tools._str(tools._rndmFloat(-100, 100, 2)), tools._str(color.red))
var aapl_vals = array.from('-185.42', '-97.48', 'false', '-12300', 'down', tools._str(tools._rndmFloat(-100, 100, 2)), tools._str(color.white))
var nvda_vals = array.from('578.25', '130.44', 'true', '50000', 'down', tools._str(tools._rndmFloat(-100, 100, 2)), tools._str(color.yellow))
var msft_vals = array.from('-391.98', '202.01', 'false', '0', 'flat', tools._str(tools._rndmFloat(-100, 100, 2)), tools._str(color.green))
var amzn_vals = array.from('475.90', '-118.12', 'false', '-1500', 'up', tools._str(tools._rndmFloat(-100, 100, 2)), tools._str(color.black))

var _kvs1 = _kvs.new(dataKeys, tsla_vals, types)
var _kvs2 = _kvs.new(dataKeys, aapl_vals, types)
var _kvs3 = _kvs.new(dataKeys, nvda_vals, types)
var _kvs4 = _kvs.new(dataKeys, msft_vals, types)
var _kvs5 = _kvs.new(dataKeys, amzn_vals, types)
var _pkvs1 = _pkvs.new(primaryKeys, array.from(_kvs1, _kvs2, _kvs3, _kvs4, _kvs5))

var _dynamic3dValues = map.new<string, dvs>()
_dynamic3dValues.put('pk', tools._rndmColorArray(5).dvs())
_dynamic3dValues.put('High', tools._rndmColorArray(7).dvs())
_dynamic3dValues.put('Size', tools._rndmColorArray(7).dvs())
_dynamic3dValues.put('Comment', tools._rndmColorArray(7).dvs())
_dynamic3dValues.put('dk', tools._rndmColorArray(7).dvs())

var _dynamic2dValues = map.new<string, dvs>()
_dynamic2dValues.put('val', tools._rndmColorArray(7).dvs())
_dynamic2dValues.put('key', tools._rndmColorArray(7).dvs())

// Testing printCellStyles

if barstate.islast
    printer1 = _printer.new(loc=position.middle_left).header('Printer 1').title(top=false).cell(horizontal=true).theme("orange").debug(true)
    printer2 = _printer.new(loc=position.middle_right).header('Printer 2').title(top=false).cell(horizontal=true).theme("purple").debug(true)
    
    styles2d = map.new<string, cellStyle>()
    cs1 = cellStyle.copy(printer2.cellStyle)
    cs1.dynamicColor := dynamicColor.new(numberDown=-100, numberUp=100, offsetItem='bg')
    cs1.gradient := true
    styles2d.put('val', cs1)

    cs2 = cellStyle.copy(printer2.keyCellStyle)
    cs2.dynamicColor := dynamicColor.new(numberDown=-100, numberUp=100, offsetItem='text')
    cs2.gradient := true
    styles2d.put('key', cs2)
    
    styles3d = map.new<string, cellStyle>()
    cs_high = cellStyle.copy(printer2.cellStyle)
    cs_high.dynamicColor := dynamicColor.new(numberDown=-100, numberUp=100, offsetItem='bg')
    cs_high.gradient := true
    styles3d.put('High', cs_high)

    cs_size = cellStyle.copy(printer2.cellStyle)
    cs_size.dynamicColor := dynamicColor.new(numberDown=-12300, numberUp=50000, offsetItem='bg')
    cs_size.gradient := true
    styles3d.put('Size', cs_size)

    cs_comment = cellStyle.copy(printer2.cellStyle)
    cs_comment.dynamicColor := dynamicColor.new(offsetItem='bg')
    cs_comment.gradient := true
    styles3d.put('Comment', cs_comment)

    pkcs = cellStyle.copy(printer2.keyCellStyle)
    pkcs.dynamicColor := dynamicColor.new(numberDown=-100, numberUp=100, offsetItem='text', offsetColor=#000000)
    pkcs.gradient := true
    styles3d.put('pk', pkcs)

    dkcs = cellStyle.copy(printer2.keyCellStyle)
    dkcs.dynamicColor := dynamicColor.new(stringUp='Random', offsetItem='text', offsetColor=#000000)
    dkcs.gradient := true
    styles3d.put('dk', dkcs)
    

    // Printer1: Single values
    printer1.print(tools._rndmString(), title='String')
    printer1.print(tools._rndmFloat(), title='Float')
    printer1.print(tools._rndmInt(), title='Integer')
    printer1.print(tools._rndmBool(), title='Boolean')
    printer1.print(tools._rndmColor(), title='Color')

    // Printer2: Single values with dynamic colors.
    printer2.print(tools._rndmString(), title='String', cellStyle=cs1)
    printer2.print(tools._rndmFloat(), title='Float', cellStyle=cs1)
    printer2.print(tools._rndmInt(), title='Integer')
    printer2.print(tools._rndmBool(), title='Boolean')
    printer2.print(tools._rndmColor(), title='Color', cellStyle=cs1)

    // Printer1: Array values
    printer1.print(tools._rndmStringArray(3), title='String Array')
    printer1.print(tools._rndmFloatArray(3), title='Float Array')

    // Printer2: Array values
    printer2.print(tools._rndmStringArray(3), title='String Array')
    printer2.print(tools._rndmFloatArray(3), title='Float Array', cellStyle=cs1)

    // Printer1: Matrix values
    printer1.print(tools._rndmIntMatrix(3, 3), title='Int Matrix', cellStyle=cs1)
    printer1.print(tools._rndmFloatMatrix(3, 3), title='Float Matrix', cellStyle=cs1)

    // Printer2: Matrix values
    printer2.print(tools._rndmBoolMatrix(3, 3), title='Bool Matrix', cellStyle=cs1)
    printer2.print(tools._rndmFloatMatrix(3, 3), title='Float Matrix', cellStyle=cs1)
    printer2.print(tools._rndmColorMatrix(3, 3), title='Color Matrix', cellStyle=cs1, dynamicValues=tools._rndmFloatMatrix(3,3, -100, 100).dvs())

    // Printer1: 2d values
    printer1.print2d(_kvs1, title='2d-Data')

    // Printer2: 2d values
    printer2.print2d(_kvs1, title='2d-Data', styles=styles2d, dynamicKey=true, dynamicValues=_dynamic2dValues)

    // Printer1: 3d values
    printer1.print3d(_pkvs1, title='3d-Data')

    // Printer2: 3d values
    printer2.print3d(_pkvs1, title='3d-Data', styles=styles3d, dynamicValues=_dynamic3dValues, dynamicKey='Long')

// }
